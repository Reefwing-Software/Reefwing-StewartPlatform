#include <Servo.h>
#include <EEPROM.h>

#include "log.h"

#define PRINT(x)  Serial.print(x)
#define PRINTLN(x)  Serial.println(x)
#define LOG(str, var)  Log:: println(str, var);

//  Number of Servos on Stewart Platform
#define SERVO_NUM 6

Servo servo[SERVO_NUM];

uint8_t ss = 0;   // Selected Servo
uint8_t servoPin[] = {2, 3, 4, 5, 6, 7};
uint16_t pw = 1500; //  Current Home Pulse Width
uint16_t hPW[] = {1500, 1500, 1500, 1500, 1500, 1500};  //  Default Home Pulse Widths in us

const char header[] = "reefwing";

int freeSRAM ()  {
  extern int __heap_start, *__brkval; 
  int v; 

  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
}

void writeStrEEPROM(const char *str, int address = 0) {
  //  Expects a NULL terminated c-string. Address defaults to zero.
  //  Uses update to minimise writes to EEPROM
  int length = strlen(str);

  for (int i = 0; i < length; i++) {
    EEPROM.update(address + i, str[i]);
  }
}

bool strInEEPROM(const char *str, int address = 0) {
  //  Returns true if the string is found at the EEPROM address
  //  provided. Address defaults to zero.
  int length = strlen(str);

  for (int i = 0; i < length; i++) {
    if (EEPROM.read(address + i) != str[i]) {
      return false;
    }
  }

  return true;
}

unsigned long crcEEPROM() {
  //  Written by Christopher Andrews.
  //  CRC algorithm generated by pycrc, MIT licence (https://github.com/tpircher/pycrc).
  //  A CRC is a simple way of checking whether data has changed or become corrupted.
  //  This method calculates a CRC value directly on the EEPROM values.
  //
  //  Modified to not include the final 4 bytes

  const unsigned long crc_table[16] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
  };

  unsigned long crc = ~0L;

  for (int index = 0; index < EEPROM.length() - 4; ++index) {
    crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);
    crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);
    crc = ~crc;
  }

  return crc;
}

void displayInstructions() {
  //  Platform Calibration Instructions
  PRINTLN(F("\n=================================================================================="));
  PRINTLN(F("                             ::Platform Calibration::"));
  PRINTLN(F("Commands - 0: Servo 0, 1: Servo 1, 2: Servo 2, 3: Servo 3, 4: Servo 4, 5: Servo 5"));
  PRINTLN(F("         - h: Home Position, <: Decrease PW, >: Increase PW, p: Print Home PW"));
  PRINTLN(F("         - a: All Servos Home, s: Save Home PW for current servo, i: Instructions"));
  PRINTLN(F("         - u: Upload saved values to EEPROM, d: Download values from EEPROM"));
  PRINTLN(F("==================================================================================\n"));
  
  PRINTLN(F("Follow this process for each servo:"));
  PRINTLN(F("    - Select the servo (0-5)"));
  PRINTLN(F("    - Enter h to move the servo to the current home position"));
  PRINTLN(F("    - Use the < and > to adjust the position"));
  PRINTLN(F("    - When at 90Â°, enter s to save.\n"));

  PRINTLN(F("When all servos have been calibrated, enter p to display"));
  PRINTLN(F("the home pulse widths (PWs) in microseconds."));
  PRINTLN(F("Finally, enter u to upload values for persistent EEPROM storage.\n"));
}

void displayCalibration() {
  unsigned long savedCRC, currentCRC = crcEEPROM();

  EEPROM.get(EEPROM.length() - 4, savedCRC);
  PRINTLN(F("============================================================================"));
  PRINTLN(F("                             ::Calibrated Home Values::"));
  LOG("Servo 0: ", hPW[0]);
  LOG("Servo 1: ", hPW[1]);
  LOG("Servo 2: ", hPW[2]);
  LOG("Servo 3: ", hPW[3]);
  LOG("Servo 4: ", hPW[4]);
  LOG("Servo 5: ", hPW[5]);
  PRINTLN(F("============================================================================\n"));
  LOG("EEPROM length (bytes): ", EEPROM.length());
  PRINT(F("Saved CRC: 0x"));
  Serial.println(savedCRC, HEX);
  PRINT(F("CRC32 of EEPROM data: 0x"));
  Serial.println(currentCRC, HEX);
  if (currentCRC != savedCRC) {
    PRINTLN(F("WARNING - saved CRC doesn't match calculated value. Data may be corrupted!"));
  }
  PRINTLN(F("============================================================================\n"));
}

void setup() {
  //  Start Serial and wait for connection
  Serial.begin(115200);
  while (!Serial);

  //  Initialise Servos and move to the default Home position
  for (uint8_t i = 0; i < SERVO_NUM; i++) {
    servo[i].attach(servoPin[i]);
    servo[i].writeMicroseconds(1500);
    delay(10);
  }

  displayInstructions();
  
  LOG("Free SRAM after Setup(): ", freeSRAM());
}

void loop() { 
  //  Read a command character
  char cmd = Serial.read(); 

  //  Parse and Handle Commands
  switch(cmd) {
    case '0':
      ss = 0;
      LOG("Servo 0 Selected, Home PW: ", hPW[0]);
    break;
    case '1':
      ss = 1;
      LOG("Servo 1 Selected, Home PW: ", hPW[1]);
    break;
    case '2':
      ss = 2;
      LOG("Servo 2 Selected, Home PW: ", hPW[2]);
    break;
    case '3':
      ss = 3;
      LOG("Servo 3 Selected, Home PW: ", hPW[3]);
    break;
    case '4':
      ss = 4;
      LOG("Servo 4 Selected, Home PW: ", hPW[4]);
    break;
    case '5':
      ss = 5;
      LOG("Servo 5 Selected, Home PW: ", hPW[5]);
    break;
    case 'a':
      for (uint8_t i = 0; i < SERVO_NUM; i++) {
        servo[i].writeMicroseconds(hPW[i]);
        delay(10);
      }
      PRINTLN(F("All Servos moved to Home.\n"));
    break;
    case 'i':
      displayInstructions();
    break;
    case 'h':
      pw = hPW[ss];
      servo[ss].writeMicroseconds(pw);
    break;
    case '<':
      pw -= 10;
      servo[ss].writeMicroseconds(pw);
    break;
    case '>':
      pw += 10;
      servo[ss].writeMicroseconds(pw);
    break;
    case 'p':
      displayCalibration();
    break;
    case 's':
      hPW[ss] = pw;
      Log::println("Saved Servo ", ss, " Pulse Width: ", pw);
    break;
    case 'u':
      writeStrEEPROM(header);

      //  Save all servo home values
      for (uint8_t i = 0; i < SERVO_NUM; i++) {
        EEPROM.put(8 + i * 2, hPW[i]);
      }

      //  Save CRC in last 4 bytes of EEPROM
      EEPROM.put(EEPROM.length() - 4, crcEEPROM());
      
      PRINTLN(F("Header, values, and CRC saved to EEPROM.\n"));
    break;
    case 'd':
      if (strInEEPROM(header)) {
        LOG("Header found in EEPROM: ", header);

        //  Load saved home values
        for (uint8_t i = 0; i < SERVO_NUM; i++) {
          EEPROM.get(8 + i * 2, hPW[i]);
        }

        displayCalibration();
      }
      else {
        PRINTLN(F("Header not found in EEPROM, unable to download Servo Home values.\n"));
      }
    break;
  }

  delay(50);
}
